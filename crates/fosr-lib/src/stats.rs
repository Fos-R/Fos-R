use crate::structs::*;

use indicatif::HumanBytes;
use indicatif::{ProgressBar, ProgressState, ProgressStyle};
use std::fmt::Write;
use std::sync::Arc;
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::thread;
use std::time::Duration;

/// Generation statistics
pub struct Stats {
    /// The target number of packets to generate
    pub packets_target: Option<u64>,
    /// The current number of generated packets
    pub packets_counter: AtomicU64,
    /// The current number of generated bytes
    pub bytes_counter: AtomicU64,
    /// Whether the generation should stop
    pub early_stop: AtomicBool,
    /// The target duration of the pcapt file (in secs)
    pub duration_target: Option<u64>, // in secs
    /// The current generated duration (in secs)
    pub current_duration: AtomicU64,  // in secs
    /// The number of received packets from the network interface
    pub received_packets: AtomicU64,
    /// The number of received but ignored packets from the network interface
    pub ignored_packets: AtomicU64,
    /// The number of packets sent to the network interface
    pub sent_packets: AtomicU64,
}

impl Default for Stats {
    fn default() -> Self {
        Stats {
            packets_counter: AtomicU64::new(0),
            packets_target: None,
            bytes_counter: AtomicU64::new(0),
            early_stop: AtomicBool::new(false),
            duration_target: None,
            current_duration: AtomicU64::new(0),
            received_packets: AtomicU64::new(0),
            ignored_packets: AtomicU64::new(0),
            sent_packets: AtomicU64::new(0),
        }
    }
}

/// The generation target. Used to stop the generation once it is reached.
pub enum Target {
    /// The target is a number of packet to generate
    PacketCount(u64),
    /// The target is a duration
    GenerationDuration(Duration),
    /// No target (for example in injection mode)
    None,
}

// For the moment, handles generation statistics only, but it will also take care of the UI

impl Stats {
    /// Creates a new "Stats" struct with a Target.
    pub fn new(target: Target) -> Self {
        let (packets_target, duration_target) = match target {
            Target::PacketCount(p) => (Some(p), None),
            Target::GenerationDuration(d) => (None, Some(d.as_secs())),
            Target::None => (None, None),
        };
        Stats {
            packets_counter: AtomicU64::new(0),
            packets_target,
            bytes_counter: AtomicU64::new(0),
            early_stop: AtomicBool::new(false),
            duration_target,
            current_duration: AtomicU64::new(0),
            received_packets: AtomicU64::new(0),
            ignored_packets: AtomicU64::new(0),
            sent_packets: AtomicU64::new(0),
        }
    }

    /// Set the current duration (in secs)
    pub fn set_current_duration(&self, secs: u64) {
        self.current_duration.fetch_max(secs, Ordering::Relaxed);
    }

    /// Increase the number of ignored packets
    pub fn packet_ignored(&self) {
        self.ignored_packets.fetch_add(1, Ordering::Relaxed);
    }

    /// Increase the number of received packets
    pub fn packet_received(&self) {
        self.received_packets.fetch_add(1, Ordering::Relaxed);
    }

    /// Increase the number of sent packets
    pub fn packet_sent(&self) {
        self.sent_packets.fetch_add(1, Ordering::Relaxed);
    }

    /// Increase statistics according to a packet
    pub fn increase(&self, p: &Packets) {
        self.packets_counter
            .fetch_add(p.packets.len() as u64, Ordering::Relaxed);
        self.bytes_counter.fetch_add(
            p.packets.iter().map(|p| p.data.len()).sum::<usize>() as u64,
            Ordering::Relaxed,
        );
    }

    /// Tell whether we reached the target or not
    pub fn should_stop(&self) -> bool {
        if let Some(target) = self.packets_target {
            self.early_stop.load(Ordering::Relaxed)
                || self.packets_counter.load(Ordering::Relaxed) >= target
        } else {
            self.early_stop.load(Ordering::Relaxed)
        }
    }

    /// Tell to stop the generation early (for example, if Ctrl+C is pressed)
    pub fn stop_early(&self) {
        self.early_stop.store(true, Ordering::Relaxed);
    }
}

fn update_progress_bar(
    stats: Arc<Stats>,
    position: &AtomicU64,
    target: u64,
    progress_bar: &mut ProgressBar,
) {
    loop {
        let c = position.load(Ordering::Relaxed);
        progress_bar.set_position(c);
        if c >= target || stats.should_stop() {
            progress_bar.finish();
            break;
        }
        thread::sleep(Duration::from_millis(10));
    }
}

/// Display the progression of the generation
pub fn show_progression(stats: Arc<Stats>) {
    if stats.packets_target.is_some() || stats.duration_target.is_some() {
        let mut progress_bar = if let Some(target) = stats.packets_target {
            ProgressBar::new(target)
        } else if let Some(target) = stats.duration_target {
            ProgressBar::new(target)
        } else {
            unreachable!()
        };
        let stats2 = Arc::clone(&stats);
        progress_bar.set_style(
            ProgressStyle::with_template(
                "{spinner:.green} Generation [{throughput}] [{wide_bar}] ({eta})",
            )
            .unwrap()
            .with_key(
                "throughput",
                move |state: &ProgressState, w: &mut dyn Write| {
                    if !state.elapsed().is_zero() {
                        let bc = stats2.bytes_counter.load(Ordering::Relaxed);
                        let throughput = (bc as f64) / state.elapsed().as_secs_f64();
                        write!(w, "{}/s", HumanBytes(throughput as u64)).unwrap();
                    }
                },
            ),
        );

        if let Some(target) = stats.packets_target {
            update_progress_bar(
                stats.clone(),
                &stats.packets_counter,
                target,
                &mut progress_bar,
            );
        } else if let Some(target) = stats.duration_target {
            update_progress_bar(
                stats.clone(),
                &stats.current_duration,
                target,
                &mut progress_bar,
            );
        }
    } else {
        while !stats.should_stop() {
            for i in 0..10 {
                thread::sleep(Duration::new(1, 0)); // check regularly if should stop
                if stats.should_stop() || i == 0 {
                    // print just before ending
                    let pc = stats.packets_counter.load(Ordering::Relaxed);
                    let sp = stats.sent_packets.load(Ordering::Relaxed);
                    let rp = stats.received_packets.load(Ordering::Relaxed);
                    let ip = stats.ignored_packets.load(Ordering::Relaxed);
                    if ip > 0 {
                        log::info!(
                            "{pc} prepared packets, {sp} sent and {rp} received (including {ip} ignored)"
                        );
                    } else {
                        log::info!("{pc} prepared packets, {sp} sent and {rp} received");
                    }
                    if stats.should_stop() {
                        break;
                    }
                }
            }
        }
    }
}
